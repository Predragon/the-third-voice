"""
UI Pages Module for The Third Voice AI
Updated for streamlit-supabase-auth integration
Contains all page-level UI components and flows
"""

import streamlit as st
import uuid
from typing import List, Optional, Tuple
from ..core.ai_engine import MessageType, RelationshipContext
from ..data.models import Contact, Message
from .components import UIComponents


class AuthenticationUI:
    """Authentication user interface - now using streamlit-supabase-auth"""
    
    def __init__(self, auth_manager):
        self.auth_manager = auth_manager
    
    def run(self) -> bool:
        """Run authentication flow using streamlit-supabase-auth"""
        
        if self.auth_manager.is_authenticated():
            return True
        
        UIComponents.render_header()
        
        st.markdown("""
        ### ðŸŽ™ï¸ Welcome to The Third Voice AI
        
        **Transform difficult conversations into healing dialogues**
        
        Sign in to start healing your relationships with AI assistance.
        """)
        
        # Use streamlit-supabase-auth's built-in login form
        # This handles Google OAuth, email/password, and all PKCE complexity internally
        self.auth_manager.render_login_form()
        
        # Add some helpful information while users are logging in
        with st.expander("âœ¨ What makes The Third Voice special?"):
            st.markdown("""
            - **ðŸ’¬ Transform**: Turn harsh words into loving messages
            - **ðŸ¤” Interpret**: Understand what people really mean when they're upset
            - **â¤ï¸ Heal**: Build stronger relationships through better communication
            - **ðŸ”’ Private**: Your conversations stay secure and private
            - **ðŸ“± Mobile**: Works perfectly on all devices
            """)
        
        return False


class OnboardingFlow:
    """First-time user onboarding - updated for streamlit-supabase-auth"""
    
    def __init__(self, db, ai_engine):
        self.db = db
        self.ai_engine = ai_engine
    
    def run(self, user_id: str, auth_manager) -> bool:
        """Run onboarding flow, return True if completed"""
        
        # Initialize onboarding state
        if 'onboarding_step' not in st.session_state:
            st.session_state.onboarding_step = 1
        
        # Render header with authentication info
        UIComponents.render_header_with_auth(auth_manager)
        
        if st.session_state.onboarding_step == 1:
            return self._step_1_welcome()
        elif st.session_state.onboarding_step == 2:
            return self._step_2_context(user_id)
        elif st.session_state.onboarding_step == 3:
            return self._step_3_problem()
        elif st.session_state.onboarding_step == 4:
            return self._step_4_ai_magic(user_id)
        elif st.session_state.onboarding_step == 5:
            return self._step_5_feedback(user_id)
        
        return True
    
    def _step_1_welcome(self) -> bool:
        """Welcome step with better user info display"""
        st.markdown("""
        ### ðŸŒŸ Transform Difficult Conversations with AI
        
        Welcome to The Third Voice - your AI relationship counselor that helps you:
        
        - ðŸ’¬ **Transform** harsh words into healing messages
        - ðŸ¤” **Interpret** what people really mean when they're upset  
        - â¤ï¸ **Heal** relationships through better communication
        - ðŸ“± **Access anywhere** - works on all devices
        
        Let's try it out with someone in your life...
        """)
        
        if st.button("Let's Start!", use_container_width=True, type="primary"):
            st.session_state.onboarding_step = 2
            st.rerun()
        
        return False
    
    def _step_2_context(self, user_id: str) -> bool:
        """Context selection step"""
        st.markdown("### Step 1: Choose Your Relationship")
        
        name = st.text_input(
            "What's their name?",
            placeholder="e.g., Sarah, Mom, Boss...",
            key="onboarding_name"
        )
        
        context_value, context_display = UIComponents.render_relationship_selector()
        
        if name and st.button("Continue", use_container_width=True, type="primary"):
            # Store the contact info
            st.session_state.onboarding_contact = {
                "name": name,
                "context": context_value,
                "context_display": context_display
            }
            st.session_state.onboarding_step = 3
            st.rerun()
        
        return False
    
    def _step_3_problem(self) -> bool:
        """Problem input step"""
        contact = st.session_state.onboarding_contact
        st.markdown(f"### Step 2: What Happened with {contact['name']}?")
        
        # Choose transform or interpret
        mode = st.radio(
            "Choose your situation:",
            [
                "ðŸ’¬ I want to say something but need help saying it better",
                "ðŸ¤” They said something and I need help understanding it"
            ],
            key="onboarding_mode"
        )
        
        if "I want to say" in mode:
            message_type = MessageType.TRANSFORM.value
            placeholder = f"What do you want to tell {contact['name']}?\n\nExample: 'I'm frustrated that you never help with chores'"
        else:
            message_type = MessageType.INTERPRET.value
            placeholder = f"What did {contact['name']} say to you?\n\nExample: 'You never appreciate anything I do!'"
        
        message = st.text_area(
            "Share the message:",
            placeholder=placeholder,
            height=150,
            key="onboarding_message"
        )
        
        if message and st.button("Get AI Help", use_container_width=True, type="primary"):
            st.session_state.onboarding_message_data = {
                "message": message,
                "type": message_type
            }
            st.session_state.onboarding_step = 4
            st.rerun()
        
        return False
    
    def _step_4_ai_magic(self, user_id: str) -> bool:
        """AI processing step"""
        contact = st.session_state.onboarding_contact
        message_data = st.session_state.onboarding_message_data
        
        st.markdown(f"### Step 3: AI Magic âœ¨")
        
        # Create temporary contact for demo
        temp_contact_id = str(uuid.uuid4())
        
        with st.spinner("The Third Voice is thinking..."):
            # Process with AI
            ai_response = self.ai_engine.process_message(
                message_data["message"],
                contact["context"],
                message_data["type"],
                temp_contact_id,
                user_id,
                self.db
            )
        
        # Display results using UIComponents
        UIComponents.render_ai_response(ai_response, message_data["type"])
        
        # Store AI response for next step
        st.session_state.onboarding_ai_response = ai_response
        
        if st.button("This is Amazing! Continue", use_container_width=True, type="primary"):
            st.session_state.onboarding_step = 5
            st.rerun()
        
        return False
    
    def _step_5_feedback(self, user_id: str) -> bool:
        """Feedback and completion step"""
        st.markdown("### Step 4: Help Us Improve")
        
        # Quick feedback
        rating = st.slider("How helpful was this?", 1, 5, 4, key="onboarding_rating")
        feedback_text = st.text_area(
            "What could be better?",
            placeholder="Your feedback helps us improve...",
            key="onboarding_feedback"
        )
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("Skip", use_container_width=True):
                return self._complete_onboarding(user_id)
        
        with col2:
            if st.button("Submit & Continue", use_container_width=True, type="primary"):
                # Save feedback
                self.db.save_feedback(user_id, rating, feedback_text, "onboarding")
                return self._complete_onboarding(user_id)
        
        return False
    
    def _complete_onboarding(self, user_id: str) -> bool:
        """Complete onboarding and create real contact"""
        
        # Create the actual contact
        contact_data = st.session_state.onboarding_contact
        contact = self.db.create_contact(
            contact_data["name"],
            contact_data["context"],
            user_id
        )
        
        if contact:
            # Save the demo message if it was successful
            if hasattr(st.session_state, 'onboarding_ai_response'):
                message_data = st.session_state.onboarding_message_data
                ai_response = st.session_state.onboarding_ai_response
                
                self.db.save_message(
                    contact.id,
                    contact.name,
                    message_data["type"],
                    message_data["message"],
                    ai_response.transformed_message,
                    user_id,
                    ai_response
                )
        
        # Clear onboarding data
        for key in list(st.session_state.keys()):
            if key.startswith('onboarding_'):
                del st.session_state[key]
        
        # Mark as completed
        st.session_state.onboarding_completed = True
        st.session_state.selected_contact = contact
        
        st.success("ðŸŽ‰ Welcome to The Third Voice! Your contact has been saved.")
        st.balloons()
        
        return True


class Dashboard:
    """Main dashboard after onboarding - updated for streamlit-supabase-auth"""
    
    def __init__(self, db, ai_engine):
        self.db = db
        self.ai_engine = ai_engine
    
    def run(self, user_id: str, auth_manager):
        """Run main dashboard"""
        
        # Get user's contacts
        contacts = self.db.get_user_contacts(user_id)
        
        if not contacts:
            # No contacts yet, show add contact flow
            self._render_add_first_contact(user_id, auth_manager)
        else:
            # Show contacts and conversation interface
            self._render_main_interface(user_id, contacts, auth_manager)
    
    def _render_add_first_contact(self, user_id: str, auth_manager):
        """Render interface to add first contact"""
        UIComponents.render_header_with_auth(auth_manager)
        
        st.markdown("""
        ### ðŸ‘¥ Add Your First Contact
        
        Start by adding someone you'd like to communicate better with.
        """)
        
        with st.form("add_contact_form"):
            name = st.text_input("Name", placeholder="e.g., Sarah, Mom, Boss...")
            context_value, context_display = UIComponents.render_relationship_selector()
            
            if st.form_submit_button("Add Contact", use_container_width=True, type="primary"):
                if name:
                    contact = self.db.create_contact(name, context_value, user_id)
                    if contact:
                        st.session_state.selected_contact = contact
                        st.success(f"Added {name} successfully!")
                        st.rerun()
                else:
                    st.error("Please enter a name")
    
    def _render_main_interface(self, user_id: str, contacts: List[Contact], auth_manager):
        """Render main interface with contacts and conversation"""
        
        # Mobile-optimized layout with auth info
        UIComponents.render_header_with_auth(auth_manager)
        
        # Also render auth info in sidebar for desktop users
        UIComponents.render_auth_sidebar(auth_manager)
        
        # Contact selection
        if len(contacts) == 1:
            selected_contact = contacts[0]
            st.session_state.selected_contact = selected_contact
        else:
            # Multiple contacts - show selector
            contact_names = [f"{c.name} ({RelationshipContext(c.context).emoji})" for c in contacts]
            selected_idx = st.selectbox(
                "Choose contact:",
                range(len(contacts)),
                format_func=lambda x: contact_names[x],
                key="contact_selector"
            )
            selected_contact = contacts[selected_idx]
            st.session_state.selected_contact = selected_contact
        
        # Main conversation interface
        self._render_conversation_interface(user_id, selected_contact)
        
        # Add new contact button
        if st.button("âž• Add Another Contact", use_container_width=True):
            st.session_state.show_add_contact = True
            st.rerun()
        
        # Handle add contact modal
        if st.session_state.get('show_add_contact', False):
            self._render_add_contact_modal(user_id)
    
    def _render_conversation_interface(self, user_id: str, contact: Contact):
        """Render the main conversation interface"""
        
        # Contact header
        context_enum = RelationshipContext(contact.context)
        UIComponents.render_contact_header(contact, context_enum)
        
        # Mode selection
        st.subheader("ðŸŽ¯ What do you need help with?")
        
        mode = st.radio(
            "Choose your situation:",
            [
                "ðŸ’¬ Transform: I want to say something better",
                "ðŸ¤” Interpret: Help me understand what they meant"
            ],
            key=f"mode_{contact.id}"
        )
        
        message_type = MessageType.TRANSFORM.value if "Transform" in mode else MessageType.INTERPRET.value
        
        # Message input
        if message_type == MessageType.TRANSFORM.value:
            placeholder = f"What do you want to tell {contact.name}?\n\nExample: 'I'm frustrated that you're always late'"
            helper_text = "ðŸ’¡ Share what you want to say, and I'll help you say it with love"
        else:
            placeholder = f"What did {contact.name} say to you?\n\nExample: 'You never listen to me!'"
            helper_text = "ðŸ’¡ Share what they said, and I'll help you understand what they really mean"
        
        st.write(helper_text)
        
        message = st.text_area(
            "Your message:",
            placeholder=placeholder,
            height=120,
            key=f"message_input_{contact.id}"
        )
        
        # Process button
        if st.button("ðŸŽ™ï¸ Get Third Voice Help", use_container_width=True, type="primary", disabled=not message):
            self._process_message(user_id, contact, message, message_type)
        
        # Show conversation history
        self._render_conversation_history(user_id, contact)
    
    def _process_message(self, user_id: str, contact: Contact, message: str, message_type: str):
        """Process message with AI"""
        
        with st.spinner("The Third Voice is thinking..."):
            ai_response = self.ai_engine.process_message(
                message, contact.context, message_type, contact.id, user_id, self.db
            )
        
        # Display results using UIComponents
        UIComponents.render_ai_response(ai_response, message_type)
        
        # Save to database
        success = self.db.save_message(
            contact.id, contact.name, message_type, message, 
            ai_response.transformed_message, user_id, ai_response
        )
        
        if success:
            st.success("ðŸ’¾ Conversation saved!")
        
        # Feedback form
        feedback_result = UIComponents.render_feedback_form(f"conversation_{contact.id}")
        if feedback_result:
            rating, feedback_text = feedback_result
            if self.db.save_feedback(user_id, rating, feedback_text, "conversation"):
                st.success("Thank you for your feedback!")
                st.rerun()
    
    def _render_conversation_history(self, user_id: str, contact: Contact):
        """Render conversation history for the selected contact"""
        
        messages = self.db.get_conversation_history(contact.id, user_id)
        
        if messages:
            st.markdown("---")
            UIComponents.render_message_history(messages)
    
    def _render_add_contact_modal(self, user_id: str):
        """Render modal to add new contact"""
        
        st.markdown("### âž• Add New Contact")
        
        with st.form("add_new_contact"):
            name = st.text_input("Name", placeholder="e.g., Sarah, Mom, Boss...")
            context_value, context_display = UIComponents.render_relationship_selector()
            
            col1, col2 = st.columns(2)
            
            with col1:
                if st.form_submit_button("Cancel", use_container_width=True):
                    st.session_state.show_add_contact = False
                    st.rerun()
            
            with col2:
                if st.form_submit_button("Add Contact", use_container_width=True, type="primary"):
                    if name:
                        contact = self.db.create_contact(name, context_value, user_id)
                        if contact:
                            st.session_state.selected_contact = contact
                            st.session_state.show_add_contact = False
                            st.success(f"Added {name} successfully!")
                            st.rerun()
                    else:
                        st.error("Please enter a name")


class AdminDashboard:
    """Admin dashboard for viewing feedback and analytics - updated for streamlit-supabase-auth"""
    
    def __init__(self, db):
        self.db = db
    
    def run(self, user_id: str, auth_manager):
        """Run admin dashboard - only for admin users"""
        
        # Check if user is admin using auth manager methods
        user_email = auth_manager.get_current_user_email()
        
        ADMIN_EMAILS = ["thethirdvoice.ai@gmail.com", "hello@thethirdvoice.ai", "pmirkovic@yahoo.com"]
        
        if not user_email or user_email not in ADMIN_EMAILS:
            st.error("ðŸ”’ Access Denied - Admin Only")
            return
        
        UIComponents.render_header_with_auth(auth_manager)
        
        st.title("ðŸŽ›ï¸ Admin Dashboard - The Third Voice")
        st.markdown("**For Samantha! For every family!** ðŸ’ª")
        
        # Show admin user info
        user_name = auth_manager.get_current_user_name()
        st.info(f"ðŸ‘‘ Admin: {user_name or user_email}")
        
        # Tabs for different admin views
        tab1, tab2, tab3 = st.tabs(["ðŸ“Š Feedback Overview", "ðŸ’¬ Detailed Feedback", "ðŸ“ˆ Analytics"])
        
        with tab1:
            self._render_feedback_overview()
        
        with tab2:
            self._render_detailed_feedback()
        
        with tab3:
            self._render_analytics()
    
    def _render_feedback_overview(self):
        """Render feedback overview with key metrics"""
        st.subheader("ðŸ“Š Feedback Overview")
        
        # Get all feedback
        feedback_data = self._get_all_feedback()
        
        if not feedback_data:
            st.warning("No feedback yet - but families are coming! ðŸš€")
            return
        
        # Key metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_feedback = len(feedback_data)
            st.metric("Total Feedback", total_feedback)
        
        with col2:
            avg_rating = sum(f['rating'] for f in feedback_data) / len(feedback_data)
            st.metric("Average Rating", f"{avg_rating:.1f}/5")
        
        with col3:
            recent_count = len([f for f in feedback_data if self._is_recent(f['created_at'])])
            st.metric("This Week", recent_count)
        
        with col4:
            high_rating_count = len([f for f in feedback_data if f['rating'] >= 4])
            satisfaction_rate = (high_rating_count / len(feedback_data)) * 100
            st.metric("Satisfaction", f"{satisfaction_rate:.0f}%")
        
        # Rating distribution
        st.subheader("â­ Rating Distribution")
        rating_counts = {}
        for i in range(1, 6):
            rating_counts[f"{i} â­"] = len([f for f in feedback_data if f['rating'] == i])
        
        st.bar_chart(rating_counts)
        
        # Recent feedback highlights
        st.subheader("ðŸ”¥ Recent Feedback Highlights")
        recent_feedback = sorted(feedback_data, key=lambda x: x['created_at'], reverse=True)[:5]
        
        for feedback in recent_feedback:
            with st.expander(f"â­{feedback['rating']} - {feedback['feature_context']} - {feedback['created_at'][:10]}"):
                if feedback['feedback_text']:
                    st.write(f"**Feedback:** {feedback['feedback_text']}")
                else:
                    st.write("*No text feedback provided*")
                st.caption(f"User: {feedback['user_id'][:8]}... | Context: {feedback['feature_context']}")
    
    def _render_detailed_feedback(self):
        """Render detailed feedback view with filtering"""
        st.subheader("ðŸ’¬ Detailed Feedback")
        
        feedback_data = self._get_all_feedback()
        
        if not feedback_data:
            st.warning("No feedback yet - but families are coming! ðŸš€")
            return
        
        # Filters
        col1, col2, col3 = st.columns(3)
        
        with col1:
            # Rating filter
            rating_filter = st.selectbox(
                "Filter by Rating",
                ["All", "5â­", "4â­", "3â­", "2â­", "1â­"]
            )
        
        with col2:
            # Context filter
            contexts = list(set(f['feature_context'] for f in feedback_data))
            context_filter = st.selectbox(
                "Filter by Context",
                ["All"] + contexts
            )
        
        with col3:
            # Date filter
            date_filter = st.selectbox(
                "Time Period",
                ["All Time", "Last 7 Days", "Last 30 Days"]
            )
        
        # Apply filters
        filtered_data = self._apply_filters(feedback_data, rating_filter, context_filter, date_filter)
        
        st.write(f"**Showing {len(filtered_data)} feedback entries**")
        
        # Display feedback
        for feedback in sorted(filtered_data, key=lambda x: x['created_at'], reverse=True):
            with st.container():
                col1, col2 = st.columns([3, 1])
                
                with col1:
                    # Rating stars
                    stars = "â­" * feedback['rating'] + "â˜†" * (5 - feedback['rating'])
                    st.markdown(f"**{stars}** ({feedback['rating']}/5)")
                    
                    # Feedback text
                    if feedback['feedback_text']:
                        st.write(feedback['feedback_text'])
                    else:
                        st.write("*Rating only - no text feedback*")
                
                with col2:
                    st.caption(f"**Context:** {feedback['feature_context']}")
                    st.caption(f"**Date:** {feedback['created_at'][:10]}")
                    st.caption(f"**User:** {feedback['user_id'][:8]}...")
                
                st.divider()
    
    def _render_analytics(self):
        """Render analytics and insights"""
        st.subheader("ðŸ“ˆ Analytics & Insights")
        
        feedback_data = self._get_all_feedback()
        
        if not feedback_data:
            st.warning("No feedback yet - but families are coming! ðŸš€")
            return
        
        # Feature context analysis
        st.subheader("ðŸŽ¯ Feedback by Feature")
        context_stats = {}
        for context in set(f['feature_context'] for f in feedback_data):
            context_feedback = [f for f in feedback_data if f['feature_context'] == context]
            context_stats[context] = {
                'count': len(context_feedback),
                'avg_rating': sum(f['rating'] for f in context_feedback) / len(context_feedback)
            }
        
        for context, stats in context_stats.items():
            col1, col2 = st.columns([3, 1])
            with col1:
                st.write(f"**{context.title()}**")
            with col2:
                st.metric(f"Avg Rating", f"{stats['avg_rating']:.1f}/5")
                st.caption(f"{stats['count']} feedback")
        
        # Timeline view
        st.subheader("ðŸ“… Feedback Timeline")
        daily_counts = {}
        for feedback in feedback_data:
            date = feedback['created_at'][:10]
            daily_counts[date] = daily_counts.get(date, 0) + 1
        
        if daily_counts:
            st.line_chart(daily_counts)
        
        # Insights
        st.subheader("ðŸ’¡ Key Insights")
        
        # Calculate insights
        total_feedback = len(feedback_data)
        high_ratings = len([f for f in feedback_data if f['rating'] >= 4])
        low_ratings = len([f for f in feedback_data if f['rating'] <= 2])
        
        insights = []
        
        if high_ratings / total_feedback > 0.8:
            insights.append("ðŸŽ‰ **Excellent!** Over 80% of users are highly satisfied!")
        elif high_ratings / total_feedback > 0.6:
            insights.append("ðŸ‘ **Good!** Majority of users are satisfied, but room for improvement.")
        else:
            insights.append("âš ï¸ **Attention needed** - User satisfaction could be improved.")
        
        if low_ratings > 0:
            insights.append(f"ðŸ” **Focus area:** {low_ratings} users gave low ratings - review their feedback closely.")
        
        # Most common feedback context
        context_counts = {}
        for f in feedback_data:
            context = f['feature_context']
            context_counts[context] = context_counts.get(context, 0) + 1
        
        if context_counts:
            top_context = max(context_counts.items(), key=lambda x: x[1])
            insights.append(f"ðŸ“Š **Most feedback comes from:** {top_context[0]} ({top_context[1]} responses)")
        
        for insight in insights:
            st.info(insight)
        
        # Export options
        st.subheader("ðŸ“¤ Export Data")
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("ðŸ“Š Export to CSV", use_container_width=True):
                csv_data = self._export_to_csv(feedback_data)
                st.download_button(
                    "Download CSV",
                    csv_data,
                    "third_voice_feedback.csv",
                    "text/csv"
                )
        
        with col2:
            if st.button("ðŸ“‹ Copy Summary", use_container_width=True):
                summary = self._generate_summary(feedback_data)
                st.code(summary)
    
    def _get_all_feedback(self):
        """Get all feedback from database"""
        try:
            response = self.db.supabase.table("feedback").select("*").order("created_at", desc=True).execute()
            return response.data
        except Exception as e:
            st.error(f"Error fetching feedback: {str(e)}")
            return []
    
    def _is_recent(self, created_at: str) -> bool:
        """Check if feedback is from last 7 days"""
        from datetime import datetime, timedelta
        try:
            feedback_date = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
            return feedback_date > datetime.now().replace(tzinfo=feedback_date.tzinfo) - timedelta(days=7)
        except:
            return False
    
    def _apply_filters(self, data, rating_filter, context_filter, date_filter):
        """Apply filters to feedback data"""
        filtered = data
        
        # Rating filter
        if rating_filter != "All":
            rating_num = int(rating_filter[0])
            filtered = [f for f in filtered if f['rating'] == rating_num]
        
        # Context filter
        if context_filter != "All":
            filtered = [f for f in filtered if f['feature_context'] == context_filter]
        
        # Date filter
        if date_filter != "All Time":
            from datetime import datetime, timedelta
            days = 7 if "7 Days" in date_filter else 30
            cutoff = datetime.now() - timedelta(days=days)
            filtered = [f for f in filtered if datetime.fromisoformat(f['created_at'].replace('Z', '+00:00')) > cutoff.replace(tzinfo=datetime.now().astimezone().tzinfo)]
        
        return filtered
    
    def _export_to_csv(self, data):
        """Export feedback to CSV format"""
        import csv
        from io import StringIO
        
        output = StringIO()
        writer = csv.DictWriter(output, fieldnames=['created_at', 'rating', 'feedback_text', 'feature_context', 'user_id'])
        writer.writeheader()
        writer.writerows(data)
        return output.getvalue()
    
    def _generate_summary(self, data):
        """Generate feedback summary"""
        total = len(data)
        avg_rating = sum(f['rating'] for f in data) / total if total > 0 else 0
        high_satisfaction = len([f for f in data if f['rating'] >= 4])
        
        return f"""
The Third Voice AI - Feedback Summary
=====================================
Total Feedback: {total}
Average Rating: {avg_rating:.1f}/5
High Satisfaction: {high_satisfaction} ({(high_satisfaction/total*100):.1f}%)

For Samantha! For every family! ðŸ’ª
        """.strip()