"""
Authentication Manager for The Third Voice AI
Simplified approach that works reliably with Streamlit Cloud
Uses implicit flow instead of PKCE to avoid session state issues
"""

import streamlit as st
from typing import Optional, Tuple
import time
from src.config.settings import AppConfig


class AuthManager:
    """Handle authentication workflows - simplified for Streamlit Cloud compatibility"""
    
    def __init__(self, db):
        self.db = db
        self.supabase = db.supabase
        print(f"Debug: Supabase client initialized: {self.supabase}")
        self._check_existing_session()
    
    def _check_existing_session(self):
        """Check if there's an existing Supabase session"""
        try:
            session = self.supabase.auth.get_session()
            if session and session.user:
                if not hasattr(st.session_state, 'user') or st.session_state.user is None:
                    st.session_state.user = session.user
                    print(f"✅ Restored session for user: {session.user.email}")
        except Exception as e:
            print(f"⚠️ Could not check existing session: {str(e)}")
    
    def sign_up(self, email: str, password: str) -> Tuple[bool, str]:
        """Sign up a new user"""
        try:
            response = self.supabase.auth.sign_up({
                "email": email,
                "password": password
            })
            if response.user:
                return True, "Check your email for verification link!"
            else:
                return False, "Sign up failed"
        except Exception as e:
            return False, f"Sign up error: {str(e)}"
    
    def sign_in(self, email: str, password: str) -> Tuple[bool, str]:
        """Sign in user"""
        try:
            response = self.supabase.auth.sign_in_with_password({
                "email": email,
                "password": password
            })
            if response.user:
                st.session_state.user = response.user
                return True, "Successfully signed in!"
            else:
                return False, "Invalid credentials"
        except Exception as e:
            return False, f"Sign in error: {str(e)}"
    
    def sign_in_with_google(self):
        """Initiate Google Sign-In using implicit flow (more reliable for Streamlit)"""
        try:
            print("Debug: Initiating Google OAuth with implicit flow")
            
            # Get current app URL for redirect
            current_url = "https://the-third-voice.streamlit.app"
            
            print(f"Debug: Redirect URL: {current_url}")
            
            # Use implicit flow instead of PKCE (more reliable for Streamlit)
            response = self.supabase.auth.sign_in_with_oauth({
                "provider": "google",
                "options": {
                    "redirect_to": current_url,
                    "scopes": "openid email profile"
                    # Removed PKCE parameters to use implicit flow
                }
            })
            
            if hasattr(response, 'url') and response.url:
                print(f"Debug: OAuth URL generated: {response.url[:50]}...")
                
                # Show a loading message
                with st.spinner("Redirecting to Google..."):
                    time.sleep(1)
                
                # Redirect using JavaScript with better error handling
                st.markdown(f"""
                <script>
                    // Function to handle the redirect
                    function redirectToGoogle() {{
                        try {{
                            window.location.href = "{response.url}";
                        }} catch (error) {{
                            console.error('Redirect failed:', error);
                            // Fallback: open in new window
                            window.open("{response.url}", "_self");
                        }}
                    }}
                    
                    // Try redirect immediately
                    redirectToGoogle();
                    
                    // Backup: redirect after short delay
                    setTimeout(redirectToGoogle, 1000);
                </script>
                """, unsafe_allow_html=True)
                
                # Fallback link with better styling
                st.markdown(f"""
                <div style="text-align: center; margin-top: 20px;">
                    <a href="{response.url}" target="_self" style="
                        background-color: #4285f4;
                        color: white;
                        padding: 12px 24px;
                        text-decoration: none;
                        border-radius: 6px;
                        font-weight: 500;
                        display: inline-block;
                    ">Continue with Google</a>
                    <p style="margin-top: 10px; color: #666; font-size: 14px;">
                        Click the button above if you weren't redirected automatically
                    </p>
                </div>
                """, unsafe_allow_html=True)
                
                st.stop()
            else:
                st.error("Failed to generate Google OAuth URL")
                print(f"Debug: OAuth response: {response}")
                
        except Exception as e:
            st.error(f"Google sign-in error: {str(e)}")
            print(f"Debug: Google sign-in error: {str(e)}")
    
    def handle_google_callback(self):
        """Handle Google OAuth callback - simplified for implicit flow"""
        print("Debug: Checking for OAuth callback")
        
        # Check if we're in the callback by looking at URL fragments or query params
        # Since Streamlit has issues with query params, we'll use a different approach
        
        # Use JavaScript to check for OAuth tokens in URL fragment
        check_fragment_js = """
        <script>
            function checkAuthFragment() {
                const hash = window.location.hash;
                const params = new URLSearchParams(hash.substring(1));
                
                const accessToken = params.get('access_token');
                const refreshToken = params.get('refresh_token');
                const error = params.get('error');
                
                if (accessToken) {
                    // Store tokens in session storage temporarily
                    sessionStorage.setItem('supabase_access_token', accessToken);
                    if (refreshToken) {
                        sessionStorage.setItem('supabase_refresh_token', refreshToken);
                    }
                    
                    // Clear the hash to avoid showing tokens in URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                    
                    // Reload to process the tokens
                    window.location.reload();
                } else if (error) {
                    sessionStorage.setItem('supabase_auth_error', error);
                    window.location.reload();
                }
            }
            
            // Check on page load
            checkAuthFragment();
        </script>
        """
        
        st.markdown(check_fragment_js, unsafe_allow_html=True)
        
        # Now check if we have tokens from sessionStorage
        get_tokens_js = """
        <script>
            const accessToken = sessionStorage.getItem('supabase_access_token');
            const refreshToken = sessionStorage.getItem('supabase_refresh_token');
            const error = sessionStorage.getItem('supabase_auth_error');
            
            // Send to parent window if available (for components)
            if (window.parent && window.parent.postMessage) {
                if (accessToken) {
                    window.parent.postMessage({
                        type: 'auth_success',
                        access_token: accessToken,
                        refresh_token: refreshToken || ''
                    }, '*');
                } else if (error) {
                    window.parent.postMessage({
                        type: 'auth_error',
                        error: error
                    }, '*');
                }
            }
            
            // Also try setting as query params for Streamlit to read
            if (accessToken && !window.location.search.includes('access_token')) {
                const newUrl = window.location.pathname + 
                              '?access_token=' + encodeURIComponent(accessToken) +
                              (refreshToken ? '&refresh_token=' + encodeURIComponent(refreshToken) : '');
                window.history.replaceState({}, document.title, newUrl);
                
                // Clean up session storage
                sessionStorage.removeItem('supabase_access_token');
                sessionStorage.removeItem('supabase_refresh_token');
            }
            
            if (error) {
                sessionStorage.removeItem('supabase_auth_error');
            }
        </script>
        """
        
        st.markdown(get_tokens_js, unsafe_allow_html=True)
        
        # Try to get query parameters (fallback method)
        try:
            query_params = dict(st.query_params)
            print(f"Debug: Query params available: {list(query_params.keys())}")
            
            if "access_token" in query_params:
                access_token = query_params["access_token"]
                refresh_token = query_params.get("refresh_token", "")
                print(f"Debug: Found access token in query params: {access_token[:20]}...")
                
                try:
                    # Set session with the tokens
                    response = self.supabase.auth.set_session(access_token, refresh_token)
                    
                    if response and hasattr(response, 'user') and response.user:
                        st.session_state.user = response.user
                        print(f"✅ User authenticated: {response.user.email}")
                        
                        # Clear query params
                        st.query_params.clear()
                        st.success("Successfully signed in with Google!")
                        time.sleep(1)
                        st.rerun()
                        return response.user
                        
                except Exception as e:
                    print(f"Debug: Token authentication failed: {str(e)}")
                    st.error("Authentication failed. Please try again.")
            
            elif "error" in query_params:
                error = query_params["error"]
                error_description = query_params.get("error_description", "No description")
                print(f"Debug: OAuth error: {error} - {error_description}")
                st.error(f"Authentication error: {error}")
                st.query_params.clear()
                
        except Exception as e:
            print(f"Debug: Query param processing error: {str(e)}")
        
        return None
    
    def sign_out(self):
        """Sign out user"""
        try:
            self.supabase.auth.sign_out()
            # Clear all session state
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            # Clear query params
            try:
                st.query_params.clear()
            except:
                pass
            print("✅ User signed out successfully")
            st.rerun()
        except Exception as e:
            st.error(f"Sign out error: {str(e)}")
    
    def is_authenticated(self) -> bool:
        """Check if user is authenticated"""
        # First handle OAuth callback if present
        callback_result = self.handle_google_callback()
        if callback_result:
            return True
        
        # Check session state first
        if hasattr(st.session_state, 'user') and st.session_state.user is not None:
            # Verify the session is still valid
            try:
                session = self.supabase.auth.get_session()
                if session and session.user:
                    print(f"Debug: User authenticated: {st.session_state.user.email}")
                    return True
                else:
                    # Session expired, clear state
                    del st.session_state.user
                    print("Debug: Session expired, cleared user state")
            except:
                # Error checking session, assume expired
                if hasattr(st.session_state, 'user'):
                    del st.session_state.user
            
        # Check Supabase session as fallback
        try:
            session = self.supabase.auth.get_session()
            if session and session.user:
                st.session_state.user = session.user
                print(f"Debug: User found in Supabase session: {session.user.email}")
                return True
                
        except Exception as e:
            print(f"Debug: Session check error: {str(e)}")
            
        return False
    
    def get_current_user_id(self) -> Optional[str]:
        """Get current user ID"""
        if self.is_authenticated():
            return st.session_state.user.id
        return None
    
    def get_current_user_email(self) -> Optional[str]:
        """Get current user email"""
        if self.is_authenticated():
            return st.session_state.user.email
        return None